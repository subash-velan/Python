Python Functions:

    Python functions are a block of code that does specific tasks. The idea is to put commonly or repeatedly run task together and make a function re-usable (Don't Repeat Yourself)

Define a function:

    Functions or method in Python can define using a keyword is called 'def'. A function might take input in the form of parameter

Syntax:

    def function_name():
        # block of code
        return expression

    def function_name(param):
        # block of code
        return expression

Types of Functions:
    1. Built-in Functions
    2. User-Defined Functions
    3. Anonymouns Functions (Lambda Functions)
    4. Recursive Functions
    5. Generator Functions (yield)
    6. Async (Coroutine) Functions
    7. Higher-Order Functions
    8. Decorator Functions
    9. Partial Functions
    10. Methods (Functions inside class)
        i. Instance Method (self)
        ii. Class Method (cls)
        iii. Static Method

    1. Built-In Functions:
       Built‑in functions in Python are predefined functions available without importing any module. They perform core operations like I/O (print, input), type conversion (int,         str, list), mathematical operations (sum, max, abs), object inspection (type, id, isinstance), and iterable utilities (len, zip, sorted). They are optimized, implemented         mostly in C, and form the foundation of Python’s functionality.

       They are part of the Python Standard Library and are loaded automatically whenever Python starts.

       Python currently provides over 60 built‑in functions like:       
       print(), len(), type(), input(), sum(), max(), min(), sorted(), int(), float(), str(), map(), filter(), zip(), pow(), open() and more.

    2. User-Defined Functions (UDF)
       User‑defined functions in Python are functions created using the def keyword to build reusable, modular, and organized code. They can accept parameters, return values,           and improve maintainability. Python supports various types of UDFs such as simple functions, default‑argument functions, variable‑length (*args, **kwargs) functions,             lambda functions, recursive functions, generator functions (yield), and async functions (async def). They help enforce clean code principles and make applications more scalable

    3. Anonymouns Functions (Lambda Functions)
       In Python, an anonymous function means that a function is without a name. As we already know the def keyword is used to define the normal functions and the lambda keyword        is used to create anonymous functions

       Example 1:
       def cube(x): return x*x*x   # without lambda
       cube_l = lambda x: x*x*x  # with lambda
        
       print(cube(2))
       print(cube_l(2))

       Example 2:
        check = lambda x: "Positive" if x > 0 else "Negative" if x < 0 else "Zero"
        print(check(5))   
        print(check(-3))  
        print(check(0))

    4. Recursive Functions:
       A recursive function is function that calls itself to sovle the problem. It is commonly used for solving mathematical and dived-and-conquer problems. Always include a base case to avoid infinte recusions

    Example:

    def factorials(n):
        if n == 1:
            return 1
        else:
            return n * factorial(n-1)

    print(factorials(5))

    5. Generator Functions:
       
        A generator function is a special type of function that returns iterator object. Instead of using return to send back a value, generator functions use yield to produce a series of results over time. The function pauses its execution after yield, maintaining its state between iterations. It does lazy evaluation

    Example:

    def func(max):
        cnt = 1
        while cnt <= max:
            yield cnt
            cnt += 1

    items = func(5)
    for i in items:
        print(i)

        Generator Expression:
        Generator expressions are a concise way to create generators. They are similar to list comprehensions but use parentheses instead of square brackets and are more memory efficient.
        
        Syntax:
        (expression for item in iterable)

        Example:
        sq = (x*x for x in range(1, 6))
        for i in sq:
            print(i)

    6. Async Functions (Coroutine Functions) - async & await:
       An async function is a function defined with async def that allows Python to perform non‑blocking, concurrent I/O operations. Instead of waiting for slow tasks (like API calls, DB queries, file/network I/O), the function pauses at await and lets the event loop run other tasks in the meantime

    Example:
    
    import asyncio
    
    async def fetch_data():
        await asyncio.sleep(1)  # simulates waiting for I/O
        return "done"
    
    async def main():
        result = await fetch_data()
        print(result)
    
    asyncio.run(main())

    Resource URL : https://www.geeksforgeeks.org/python/python-async/

    7. Higher-Order Function:
       A higher-order function is a function that can take other functions as arguments and/or return functions as outputs. These functions allow you to write more concise,        flexible, and abstract code

        Example:

        def apply_to_each(func, iterable):
            return [func(x) for x in iterable]
        
        def square(x):
            return x * x
        
        numbers = [1, 2, 3, 4, 5]
        squared_numbers = apply_to_each(square, numbers)
        print(squared_numbers) # Output: [1, 4, 9, 16, 25]

        There are several higher-order functions in Python that are commonly used, such as map, filter, and reduce

    Resource URL: https://martinxpn.medium.com/higher-order-functions-in-python-33-100-days-of-python-7bfd66d516d8

    8. Decorator Function:

    Resource URL: https://www.geeksforgeeks.org/python/decorators-in-python/

        In Python, decorators are flexible way to modify or extend behavior of functions or methods, without changing their actual code.

        A decorator is essentially a function that takes another function as an argument and returns a new function with enhanced functionality.

        Decorators are often used in scenarios such as logging, authentication and memorization, allowing us to add additional functionality to existing functions or                methods in a clean, reusable way.

        Example: 

        def decorator(func):
            def wrapper():
                print("Before calling the functions")
                func()
                print("After calling the functions")
            return wrapper

        @decorator #Applying the decorator to a function
        def greet():
            print("Hello!")

        greet()

        Types of Decorators:
        1. Function Decorators
        2. Method Decorators
        3. Class Decorators
            Example:
            def fun(cls):
                cls.class_name = cls.__name__
                return cls
            
            @fun
            class Person:
                pass
            print(Person.class_name)

            Output:
            Person
        4. Built-in Decorators (@property, @staticmethod, @classmethod)

    9. Partial Function

       Partial functions in Python is a function that is created by fixing a certain number of arguments of another function. Python provides a built-in module called              functools that includes a function called partial that can be used to create partial functions. The partial function takes a callable (usually another function) and         a series of arguments to be pre-filled in the new partial function

       Example:

       Partial functions support both positional and keyword arguments to be used as fixed arguments.

        from functools import partial

        # A normal function
        def f(a, b, c, x):
            return 1000*a + 100*b + 10*c + x
        
        # A partial function that calls f with
        # a as 3, b as 1 and c as 4.
        g = partial(f, 3, 1, 4)
        
        # Calling g()
        print(g(5))

    10. Methods(inside class):

        A method in Python is simply a function that is defined inside a class and is meant to operate on objects (instances) of that class.

        i. Instance Method:
            Takes self as the first parameter
            Can access and modify instance variables
        
        ii. Class Method:
            Uses the decorator @classmethod
            Takes cls (the class itself) as the first parameter
            Can access/modify class variables, not instance variables (cls)
            Often used as factory methods

        iii. Static Method
            Uses the decorator @staticmethod
            Takes no automatic first argument (no self, no cls)
            Behaves like a normal function but lives inside a class for organization or logical grouping
            Calls by using class name

            Example:
            
            class Math:
                @staticmethod
                def add(a, b):   # static method
                    return a + b
            
            print(Math.add(3, 5))  # 8

    11. Nested Functions:

        A function defined inside another function is called an inner function (or nested function). It can access variables from the enclosing function’s scope and is often used to keep logic protected and organized.

        Example:

        def f1():
            s = 'I love GeeksforGeeks'
            def f2():
                print(s)
                
            f2()
        f1()

Pass by Reference and Pass by Value:

    In Python, variables are references to objects. When we pass them to a function, the behavior depends on whether the object is mutable (like lists, dictionaries) or         immutable (like integers, strings, tuples).

    Mutable objects: Changes inside the function affect the original object.
    Immutable objects: The original value remains unchanged.

    Example:

    # Function modifies the first element of list
    def myFun(x):
        x[0] = 20
    
    lst = [10, 11, 12, 13]
    myFun(lst)
    print(lst)   # list is modified
    
    # Function tries to modify an integer
    def myFun2(x):
        x = 20
    
    a = 10
    myFun2(a)
    print(a)     # integer is not modified

    Note: Technically, Python uses "pass-by-object-reference". Mutable objects behave like pass by reference, while immutable objects behave like pass by value
